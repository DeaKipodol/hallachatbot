# 챗봇 로직 분리 계획 (Phase 3)

> **목표**: routes.py의 복잡한 챗봇 로직을 ChatbotStream으로 완전히 분리하여, 프론트엔드가 단순히 챗봇 객체만 import하면 모든 기능을 사용할 수 있도록 만들기

**작성일**: 2025-10-09  
**상태**: 설계 단계

---

## 📁 현재 파일 구조

```
app/
├── __init__.py
├── main.py                          # FastAPI 앱 진입점
├── apikey.env                       # 환경 변수
├── requirements.txt
├── pyproject.toml
├── uv.lock
│
├── api/                             # API 라우터
│   └── routes.py                    # ⚠️ 440줄의 복잡한 챗봇 로직 포함
│
├── chatbotDirectory/                # 챗봇 핵심 로직
│   ├── __init__.py
│   ├── chatbot.py                   # ChatbotStream 클래스
│   ├── character.py                 # 캐릭터 설정
│   ├── common.py                    # 공통 설정 (model, client)
│   ├── functioncalling.py           # 함수 호출 분석/실행
│   └── rag/                         # RAG 모듈 (Phase 2 완료)
│       ├── __init__.py
│       ├── service.py               # RagService (오케스트레이터)
│       ├── gate.py                  # 규정 질문 분류
│       ├── retriever.py             # Pinecone 벡터 검색
│       ├── repository.py            # MongoDB 문서 조회
│       ├── context_builder.py       # 컨텍스트 조립
│       └── constants.py
│
├── loding/                          # ⚠️ 오타 (loading → loding)
│   ├── __init__.py
│   ├── documentLoding.py            # 문서 로딩
│   ├── mongodbConnect.py            # MongoDB 연결
│   ├── vector_db_upload.py          # 벡터 DB 업로드
│   └── 임시/
│
├── pdfs/                            # 규정 문서 원본 (30+ hwp/hwpx 파일)
│
├── docs/                            # 문서
│   ├── RAG_분리_계획.md
│   ├── 챗봇_로직_분리_계획.md        # 📍 현재 파일
│   └── progress_log.md
│
├── test.py                          # ⚠️ 루트에 흩어진 테스트 파일
├── test_stream_chat.py
└── .venv/                           # Python 가상환경
```

### 🚨 현재 구조의 문제점

1. **디렉토리 명명 문제**
   - `loding` → 오타 (올바른 이름: `loading` 또는 `data`)
   - `chatbotDirectory` → 일관성 없는 명명 (camelCase vs snake_case)

2. **AI 관련 파일 분산**
   - 챗봇, RAG, 함수 호출, 데이터 로딩이 여러 디렉토리에 흩어짐
   - AI 관련 로직을 한곳에 모아야 관리 용이

3. **테스트 파일 분산**
   - `test.py`, `test_stream_chat.py`가 루트에 위치
   - 통합 테스트 디렉토리 필요

4. **라우터에 로직 집중**
   - `api/routes.py`에 440줄의 챗봇 로직
   - 비즈니스 로직과 라우팅 책임 분리 필요

---

## 🎯 개선된 파일 구조 (Phase 3 목표)

```
app/
├── __init__.py
├── main.py                          # FastAPI 앱 진입점
├── apikey.env
├── requirements.txt
├── pyproject.toml
├── uv.lock
│
├── api/                             # 🔄 API 라우터 (단순화)
│   ├── __init__.py
│   └── routes.py                    # ✅ 10줄 미만 (chatbot.stream_chat() 호출만)
│
├── ai/                              # 🆕 AI 관련 통합 디렉토리
│   ├── __init__.py
│   │
│   ├── chatbot/                     # 챗봇 핵심 (기존 chatbotDirectory)
│   │   ├── __init__.py
│   │   ├── stream.py                # ✅ ChatbotStream (stream_chat 포함)
│   │   ├── metadata.py              # 🆕 RagMetadata, FunctionCallMetadata, ChatMetadata
│   │   ├── character.py             # 캐릭터 설정
│   │   └── config.py                # 공통 설정 (model, client)
│   │
│   ├── rag/                         # RAG 모듈 (Phase 2 완료)
│   │   ├── __init__.py
│   │   ├── service.py               # RagService
│   │   ├── gate.py                  # 규정 질문 분류
│   │   ├── retriever.py             # Pinecone 벡터 검색
│   │   ├── repository.py            # MongoDB 문서 조회
│   │   ├── context_builder.py       # 컨텍스트 조립
│   │   └── constants.py
│   │
│   ├── functions/                   # 함수 호출 (기존 functioncalling.py)
│   │   ├── __init__.py
│   │   ├── analyzer.py              # FunctionCalling 클래스
│   │   ├── tools.py                 # 도구 정의 (tools 리스트)
│   │   ├── web_search.py            # 웹 검색 함수
│   │   ├── cafeteria.py             # 학식 메뉴 함수
│   │   ├── notice.py                # 공지사항 함수
│   │   └── schedule.py              # 학사일정 함수
│   │
│   └── data/                        # 🔄 데이터 관련 (기존 loding)
│       ├── __init__.py
│       ├── document_loader.py       # 문서 로딩 (기존 documentLoding.py)
│       ├── mongodb_client.py        # MongoDB 연결 (기존 mongodbConnect.py)
│       └── vector_uploader.py       # 벡터 DB 업로드 (기존 vector_db_upload.py)
│
├── pdfs/                            # 규정 문서 원본
│
├── docs/                            # 문서
│   ├── RAG_분리_계획.md
│   ├── 챗봇_로직_분리_계획.md
│   └── progress_log.md
│
├── tests/                           # 🆕 테스트 통합 디렉토리
│   ├── __init__.py
│   ├── test_chatbot.py              # 챗봇 테스트 (기존 test.py)
│   ├── test_stream_chat.py          # 스트리밍 테스트
│   ├── test_rag.py                  # RAG 테스트
│   └── test_functions.py            # 함수 호출 테스트
│
└── .venv/
```

---

## 🔄 주요 변경 사항

### 1. AI 관련 통합 (`ai/` 디렉토리 신설)

**변경 전:**
```
app/
├── chatbotDirectory/
├── loding/
└── (functioncalling은 chatbotDirectory 내부)
```

**변경 후:**
```
app/
└── ai/
    ├── chatbot/      # 챗봇 스트리밍, 메타데이터
    ├── rag/          # RAG 검색
    ├── functions/    # 함수 호출 (웹검색, 학식 등)
    └── data/         # 데이터 로딩, MongoDB, 벡터 업로드
```

**장점:**
- AI 관련 모든 로직을 한곳에서 관리
- 명확한 계층 구조 (chatbot → rag, functions 의존)
- import 경로 일관성: `from app.ai.chatbot import ...`

---

### 2. 챗봇 모듈 재구성 (`ai/chatbot/`)

**변경 전:**
```python
# chatbotDirectory/chatbot.py (422줄)
class ChatbotStream:
    def __init__(self, model, system_role, instruction, **kwargs):
        # ...
    
    def _send_request_Stream(self, temp_context=None):
        # OpenAI 스트리밍 로직
```

**변경 후:**
```python
# ai/chatbot/stream.py (~800줄)
from .metadata import RagMetadata, FunctionCallMetadata, ChatMetadata

class ChatbotStream:
    async def stream_chat(self, message: str, language: str = "KOR"):
        """통합 스트리밍 메서드 (routes.py 로직 모두 흡수)"""
        # 1. 언어별 지침 추가
        # 2. RAG 컨텍스트 준비
        # 3. 함수 호출 분석/실행
        # 4. 최종 컨텍스트 구성
        # 5. 스트리밍 응답 생성
        # 6. 메타데이터 전송
        pass
```

```python
# ai/chatbot/metadata.py (새 파일)
@dataclass
class RagMetadata:
    """RAG 검색 메타데이터"""
    is_regulation: bool
    gate_reason: str
    context_source: str
    # ...

@dataclass
class FunctionCallMetadata:
    """함수 호출 메타데이터"""
    name: str
    arguments: Dict[str, Any]
    output: str
    # ...

@dataclass
class ChatMetadata:
    """챗봇 응답 전체 메타데이터"""
    rag: Optional[RagMetadata] = None
    functions: List[FunctionCallMetadata] = None
    web_search_status: Optional[str] = None
```

---

### 3. 함수 호출 모듈화 (`ai/functions/`)

**변경 전:**
```python
# chatbotDirectory/functioncalling.py (모든 함수가 하나의 파일)
class FunctionCalling:
    # ...

def search_internet(query, chat_context):
    # ...

def get_halla_cafeteria_menu(date, meal):
    # ...

tools = [...]  # 모든 도구 정의
```

**변경 후:**
```python
# ai/functions/analyzer.py
class FunctionCalling:
    """함수 호출 분석 및 실행"""
    def analyze(self, user_message, tools):
        # ...

# ai/functions/web_search.py
def search_internet(query: str, chat_context: List[Dict]) -> str:
    """웹 검색 함수"""
    # ...

# ai/functions/cafeteria.py
def get_halla_cafeteria_menu(date: str, meal: Optional[str] = None) -> str:
    """학식 메뉴 조회"""
    # ...

# ai/functions/tools.py
from .web_search import search_internet
from .cafeteria import get_halla_cafeteria_menu

tools = [
    {
        "type": "function",
        "function": {
            "name": "search_internet",
            # ...
        }
    },
    # ...
]
```

**장점:**
- 함수별 파일 분리로 유지보수 용이
- 새 함수 추가 시 독립적인 파일로 관리
- 테스트 작성 용이 (`test_functions.py`에서 함수별 테스트)

---

### 4. 데이터 처리 통합 (`ai/data/`)

**변경 전:**
```
loding/                    # ⚠️ 오타
├── documentLoding.py      # ⚠️ 오타
├── mongodbConnect.py
└── vector_db_upload.py
```

**변경 후:**
```
ai/data/
├── document_loader.py     # ✅ 수정
├── mongodb_client.py      # ✅ 명확한 이름
└── vector_uploader.py     # ✅ 일관성
```

**변경 이유:**
- 오타 수정 (`loding` → `data`, `documentLoding` → `document_loader`)
- snake_case 명명 규칙 일관성
- AI 관련 데이터 처리를 `ai/` 하위로 이동

---

### 5. 테스트 통합 (`tests/`)

**변경 전:**
```
app/
├── test.py
└── test_stream_chat.py
```

**변경 후:**
```
tests/
├── __init__.py
├── test_chatbot.py         # 챗봇 기본 기능
├── test_stream_chat.py     # 스트리밍 테스트
├── test_rag.py             # RAG 모듈 테스트
└── test_functions.py       # 함수 호출 테스트
```

**장점:**
- 테스트 파일 중앙 관리
- 모듈별 테스트 분리
- `pytest` 실행 시 자동 발견

---

### 6. API 라우터 단순화 (`api/routes.py`)

**변경 전 (440줄):**
```python
@router.post("/chat")
async def stream_chat(user_input: UserRequest):
    # 1. 사용자 메시지 추가
    chatbot.add_user_message_in_context(user_input.message)
    
    # 2. 언어별 지침 추가
    instruction_map = {...}
    chatbot.context[-1]["content"] += " " + instruction
    
    # 3. RAG 컨텍스트 준비 (80줄)
    rag_result = chatbot.rag_service.build_context(...)
    condense_prompt = [...]
    condensed = client.responses.create(...)
    
    # 4. 함수 호출 분석/실행 (120줄)
    analyzed = func_calling.analyze(...)
    for tool_call in analyzed:
        func_response = func_to_call(**func_args)
        func_msgs.extend([...])
    
    # 5. 학식 보강 로직 (40줄)
    # ...
    
    # 6. 최종 컨텍스트 구성 (160줄)
    sections = []
    # ...
    
    # 7. 스트리밍 응답 생성 (60줄)
    async def generate_with_tool():
        # ...
    
    return StreamingResponse(generate_with_tool(), media_type="text/plain")
```

**변경 후 (~10줄):**
```python
from app.ai.chatbot import ChatbotStream
from app.ai.chatbot.config import model

chatbot = ChatbotStream(
    model=model.advanced,
    system_role="...",
    instruction="...",
)

@router.post("/chat")
async def stream_chat(user_input: UserRequest):
    """챗봇 스트리밍 엔드포인트"""
    return StreamingResponse(
        chatbot.stream_chat(
            message=user_input.message,
            language=user_input.language
        ),
        media_type="application/x-ndjson"
    )
```

---

## 🔀 Import 경로 변경

### Before (현재)
```python
from app.chatbotDirectory.chatbot import ChatbotStream
from app.chatbotDirectory.functioncalling import FunctionCalling, tools
from app.chatbotDirectory.common import model, client
from app.loding.vector_db_upload import get_embedding, index
from app.loding.mongodbConnect import MongoDBClient
```

### After (Phase 3)
```python
# 챗봇
from app.ai.chatbot import ChatbotStream
from app.ai.chatbot.metadata import RagMetadata, FunctionCallMetadata
from app.ai.chatbot.config import model, client

# RAG
from app.ai.rag import RagService

# 함수 호출
from app.ai.functions import FunctionCalling
from app.ai.functions.tools import tools

# 데이터
from app.ai.data.vector_uploader import get_embedding, index
from app.ai.data.mongodb_client import MongoDBClient
```

**장점:**
- 명확한 계층 구조 (`app.ai.*`)
- 일관된 명명 규칙 (snake_case)
- IDE 자동완성 친화적

---

## 📌 현재 문제점

### 1. routes.py에 챗봇 로직이 강하게 결합됨 (440줄)

```python
# 현재 routes.py의 /chat 엔드포인트 구조
@router.post("/chat")
async def stream_chat(user_input: UserRequest):
    # 1) 사용자 메시지 추가 (5줄)
    chatbot.add_user_message_in_context(user_input.message)
    
    # 2) 언어별 지침 추가 (10줄)
    instruction_map = {...}
    chatbot.context[-1]["content"] += " " + instruction
    
    # 3) RAG 컨텍스트 준비 (80줄)
    rag_result = chatbot.rag_service.build_context(...)
    condense_prompt = [...]  # 긴 규정 문서 요약
    condensed = client.responses.create(...)
    
    # 4) 함수 호출 분석/실행 (120줄)
    analyzed = func_calling.analyze(...)
    for tool_call in analyzed:
        func_response = func_to_call(**func_args)
        func_msgs.extend([...])
    
    # 5) 학식 보강 로직 (40줄)
    if cafeteria_keywords and not already_called:
        caf_out = get_cafeteria_fn(**caf_args)
    
    # 6) 최종 컨텍스트 구성 (160줄)
    sections = []
    sections.append("[사용자쿼리지침]...")
    sections.append("[기억검색지침]...")
    sections.append("[웹검색지침]...")
    temp_context.append({"role": "system", "content": "\n\n".join(sections)})
    
    # 7) 스트리밍 응답 생성 (60줄)
    async def generate_with_tool():
        stream = client.responses.create(...)
        for event in stream:
            yield event.delta
    
    return StreamingResponse(generate_with_tool(), media_type="text/plain")
```

**문제점:**
- ❌ 프론트엔드가 RAG 로직, 함수 호출, 컨텍스트 구성을 모두 이해해야 함
- ❌ 챗봇 사용을 위해 440줄의 복잡한 코드 필요
- ❌ 재사용 불가능 (다른 엔드포인트에서 챗봇 사용 시 코드 중복)
- ❌ 테스트 어려움 (라우터 레벨에서만 테스트 가능)

---

## ✅ 목표 구조

### 프론트엔드가 원하는 단순함

```python
# 리팩터링 후: routes.py (10줄 미만)
@router.post("/chat")
async def stream_chat(user_input: UserRequest):
    """
    챗봇 스트리밍 엔드포인트
    - 모든 로직은 ChatbotStream.stream_chat()에 위임
    - 라우터는 단순히 요청/응답만 처리
    """
    return StreamingResponse(
        chatbot.stream_chat(
            message=user_input.message,
            language=user_input.language
        ),
        media_type="application/x-ndjson"  # JSON Lines 형식
    )
```

### ChatbotStream이 제공할 인터페이스

```python
class ChatbotStream:
    async def stream_chat(
        self, 
        message: str, 
        language: str = "KOR"
    ) -> AsyncGenerator[str, None]:
        """
        통합 챗봇 스트리밍 메서드
        
        Args:
            message: 사용자 질문
            language: 응답 언어 (KOR, ENG, VI, JPN, CHN, UZB, MNG, IDN)
        
        Yields:
            JSON Lines 형식의 문자열:
            - {"type": "delta", "content": "텍스트 청크"}
            - {"type": "metadata", "rag": {...}, "functions": [...]}
            - {"type": "done"}
        
        처리 흐름:
            1. 언어별 지침 추가
            2. RAG 컨텍스트 준비 (규정 검색)
            3. 함수 호출 분석/실행 (웹검색, 학식 등)
            4. 최종 컨텍스트 구성
            5. OpenAI 스트리밍 응답 생성
            6. 메타데이터 전송 (RAG 결과, 함수 호출 내역)
        """
        pass
```

---

## 📐 상세 설계

### 1. 데이터 구조 정의

#### 1.1 RagMetadata 클래스

```python
from dataclasses import dataclass
from typing import Optional, List, Dict, Any

@dataclass
class RagMetadata:
    """RAG 검색 결과 메타데이터"""
    
    # 기본 정보
    is_regulation: bool
    """규정 질문 여부 (gate 판단 결과)"""
    
    gate_reason: str
    """gate 판단 근거 (LLM 추론 또는 키워드 매칭)"""
    
    # 컨텍스트 소스
    context_source: str
    """컨텍스트 출처: "mongo" (DB 본문) | "preview" (Pinecone 미리보기) | "none" (자료 없음)"""
    
    # 검색 통계
    hits_count: int
    """Pinecone 검색 히트 수"""
    
    document_count: int
    """MongoDB에서 가져온 문서 수"""
    
    preview_count: int
    """Pinecone 미리보기 사용 수 (fallback)"""
    
    # 원본 데이터 (디버그/관리자용)
    chunk_ids: Optional[List[str]] = None
    """MongoDB 청크 ID 목록"""
    
    condensed_context: Optional[str] = None
    """요약된 컨텍스트 (LLM으로 가공된 버전)"""

    def to_dict(self) -> Dict[str, Any]:
        """JSON 직렬화용 딕셔너리 변환"""
        return {
            "is_regulation": self.is_regulation,
            "gate_reason": self.gate_reason,
            "context_source": self.context_source,
            "hits_count": self.hits_count,
            "document_count": self.document_count,
            "preview_count": self.preview_count,
            "chunk_ids": self.chunk_ids,
            "has_condensed_context": bool(self.condensed_context),
        }
```

#### 1.2 FunctionCallMetadata 클래스

```python
@dataclass
class FunctionCallMetadata:
    """함수 호출 결과 메타데이터"""
    
    name: str
    """함수 이름"""
    
    arguments: Dict[str, Any]
    """함수 인자"""
    
    output: str
    """함수 실행 결과"""
    
    call_id: str
    """호출 ID"""
    
    is_fallback: bool = False
    """보강 호출 여부 (LLM이 아닌 규칙 기반 호출)"""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "arguments": self.arguments,
            "output": self.output[:200] + "..." if len(self.output) > 200 else self.output,  # 축약
            "call_id": self.call_id,
            "is_fallback": self.is_fallback,
        }
```

#### 1.3 ChatMetadata 클래스 (전체 메타데이터 컨테이너)

```python
@dataclass
class ChatMetadata:
    """챗봇 응답 전체 메타데이터"""
    
    rag: Optional[RagMetadata] = None
    """RAG 검색 메타데이터 (규정 질문인 경우만)"""
    
    functions: List[FunctionCallMetadata] = None
    """함수 호출 메타데이터 목록"""
    
    web_search_status: Optional[str] = None
    """웹검색 상태: "ok" | "empty-or-error" | "not-run" """
    
    def __post_init__(self):
        if self.functions is None:
            self.functions = []
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "rag": self.rag.to_dict() if self.rag else None,
            "functions": [f.to_dict() for f in self.functions],
            "web_search_status": self.web_search_status,
        }
```

---

### 2. ChatbotStream.stream_chat() 구현 계획

#### 2.1 메서드 시그니처

```python
async def stream_chat(
    self, 
    message: str, 
    language: str = "KOR"
) -> AsyncGenerator[str, None]:
    """
    통합 챗봇 스트리밍 메서드
    
    현재 routes.py의 모든 로직을 여기로 이동:
    - 언어별 지침 추가
    - RAG 컨텍스트 준비 (요약 포함)
    - 함수 호출 분석/실행
    - 학식 보강 로직
    - 최종 컨텍스트 구성
    - 스트리밍 응답 생성
    - 메타데이터 전송
    """
```

#### 2.2 처리 흐름 (Pseudo Code)

```python
async def stream_chat(self, message: str, language: str = "KOR"):
    # === 1단계: 초기화 ===
    self.add_user_message_in_context(message)
    metadata = ChatMetadata()
    
    # === 2단계: 언어별 지침 추가 ===
    instruction = self._get_language_instruction(language)
    self.context[-1]["content"] += " " + instruction
    
    # === 3단계: RAG 컨텍스트 준비 ===
    rag_result = self.rag_service.build_context(message)
    condensed_rag = None
    if rag_result.context_text:
        condensed_rag = await self._condense_rag_context(
            message, rag_result.context_text
        )
        metadata.rag = RagMetadata(
            is_regulation=rag_result.is_regulation,
            gate_reason=rag_result.gate_reason,
            context_source=rag_result.context_source,
            hits_count=len(rag_result.hits),
            document_count=rag_result.document_count,
            preview_count=rag_result.preview_count,
            chunk_ids=rag_result.chunk_ids,
            condensed_context=condensed_rag,
        )
    
    # === 4단계: 함수 호출 분석/실행 ===
    func_results = await self._analyze_and_execute_functions(message)
    metadata.functions = func_results
    
    # === 5단계: 최종 컨텍스트 구성 ===
    final_context = self._build_final_context(
        message=message,
        condensed_rag=condensed_rag,
        func_results=func_results,
    )
    
    # === 6단계: 스트리밍 응답 생성 ===
    completed_text = ""
    async for chunk in self._stream_openai_response(final_context):
        if chunk["type"] == "delta":
            yield json.dumps(chunk, ensure_ascii=False) + "\n"
        elif chunk["type"] == "completed":
            completed_text = chunk["text"]
    
    # === 7단계: 메타데이터 전송 ===
    yield json.dumps({
        "type": "metadata",
        "data": metadata.to_dict()
    }, ensure_ascii=False) + "\n"
    
    # === 8단계: 완료 신호 ===
    yield json.dumps({"type": "done"}, ensure_ascii=False) + "\n"
    
    # === 9단계: 응답 저장 ===
    self.add_response_stream(completed_text)
```

#### 2.3 헬퍼 메서드들

```python
class ChatbotStream:
    # === 언어별 지침 ===
    def _get_language_instruction(self, language: str) -> str:
        """언어 코드에 따른 응답 지침 반환"""
        instruction_map = {
            "KOR": "한국어로 정중하고 따뜻하게 답해주세요.",
            "ENG": "Please respond kindly in English.",
            "VI": "Vui lòng trả lời bằng tiếng Việt một cách nhẹ nhàng.",
            "JPN": "日本語で丁寧に温かく答えてください。",
            "CHN": "请用中文亲切地回答。",
            "UZB": "Iltimos, o'zbek tilida samimiy va hurmat bilan javob bering.",
            "MNG": "Монгол хэлээр эелдэг, дулаахан хариулна уу.",
            "IDN": "Tolong jawab dengan ramah dan hangat dalam bahasa Indonesia."
        }
        return instruction_map.get(language, instruction_map["KOR"])
    
    # === RAG 컨텍스트 요약 ===
    async def _condense_rag_context(
        self, 
        user_question: str, 
        raw_context: str
    ) -> str:
        """
        긴 RAG 컨텍스트를 사용자 질문에 맞게 요약
        - 표/번호조항의 전체 맥락 포함 (최소 15줄)
        - 주석(주) 포함
        - 원문 구조 유지
        """
        # routes.py의 condense_prompt 로직 이동
        # ...
        pass
    
    # === 함수 호출 ===
    async def _analyze_and_execute_functions(
        self, 
        message: str
    ) -> List[FunctionCallMetadata]:
        """
        함수 호출 분석 및 실행
        1) FunctionCalling.analyze()로 필요한 함수 파악
        2) 각 함수 실행
        3) 학식 보강 로직 (키워드 기반 fallback)
        4) 결과를 FunctionCallMetadata 리스트로 반환
        """
        # routes.py의 함수 호출 로직 이동
        # ...
        pass
    
    # === 최종 컨텍스트 구성 ===
    def _build_final_context(
        self,
        message: str,
        condensed_rag: Optional[str],
        func_results: List[FunctionCallMetadata],
    ) -> List[Dict[str, str]]:
        """
        최종 LLM 입력 컨텍스트 구성
        - 사용자 쿼리 지침
        - 일반 지침
        - 기억검색 지침 + 내용
        - 웹검색 지침 + 결과
        - 함수결과 지침 + 내용
        - 통합 지침
        """
        # routes.py의 sections 구성 로직 이동
        # ...
        pass
    
    # === OpenAI 스트리밍 ===
    async def _stream_openai_response(
        self, 
        context: List[Dict[str, str]]
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """
        OpenAI Responses API 스트리밍 호출
        - event.delta 발생 시 {"type": "delta", "content": ...} yield
        - response.completed 시 {"type": "completed", "text": ...} yield
        """
        # routes.py의 generate_with_tool() 로직 이동
        # ...
        pass
```

---

### 3. 응답 포맷 (JSON Lines)

#### 3.1 실시간 텍스트 청크

```json
{"type": "delta", "content": "안녕하세요"}
{"type": "delta", "content": " 졸업"}
{"type": "delta", "content": " 규정에"}
{"type": "delta", "content": " 대해"}
```

#### 3.2 메타데이터 (응답 완료 후)

```json
{
  "type": "metadata",
  "data": {
    "rag": {
      "is_regulation": true,
      "gate_reason": "LLM 판단: 졸업 규정 관련 질문",
      "context_source": "mongo",
      "hits_count": 5,
      "document_count": 3,
      "preview_count": 0,
      "chunk_ids": ["673abc123...", "673def456..."],
      "has_condensed_context": true
    },
    "functions": [
      {
        "name": "search_internet",
        "arguments": {"query": "한라대 졸업 요건"},
        "output": "검색 결과: ...",
        "call_id": "call_123",
        "is_fallback": false
      }
    ],
    "web_search_status": "ok"
  }
}
```

#### 3.3 완료 신호

```json
{"type": "done"}
```

---

### 4. routes.py 리팩터링 후 코드

#### 4.1 전체 코드 (10줄 미만)

```python
from fastapi import APIRouter, HTTPException 
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from app.chatbotDirectory.chatbot import ChatbotStream
from app.chatbotDirectory.common import model

router = APIRouter()

# 챗봇 인스턴스 생성
chatbot = ChatbotStream(
    model=model.advanced,
    system_role="""당신은 학교 생활, 학과 정보, 행사 등 사용자가 궁금한 점이 있으면 아는 범위 안에서 대답합니다. 단 절대 거짓내용을 말하지 않습니다. 아는 범위에서 말하고 부족한 부분은 인정하세요.
    당신은 실시간으로 검색하는 기능이있습니다.
    당신은 한라대 공지사항을 탐색할 수 있습니다.
    당신은 한라대 학식메뉴를 탐색할 수 있습니다.
    당신은 한라대 학사일정을 탐색할 수 있습니다.""",
    instruction="당신은 사용자의 질문에 답변하는 역할을 합니다.",
)

class UserRequest(BaseModel):
    message: str
    language: str = "KOR"

@router.post("/chat")
async def stream_chat(user_input: UserRequest):
    """
    챗봇 스트리밍 엔드포인트
    
    Request Body:
        {
            "message": "졸업 규정을 알려주세요",
            "language": "KOR"
        }
    
    Response (JSON Lines):
        {"type": "delta", "content": "안녕하세요"}
        {"type": "delta", "content": " 졸업"}
        {"type": "metadata", "data": {...}}
        {"type": "done"}
    """
    return StreamingResponse(
        chatbot.stream_chat(
            message=user_input.message,
            language=user_input.language
        ),
        media_type="application/x-ndjson"
    )
```

#### 4.2 FunctionCalling 초기화는 어디서?

**옵션 A: ChatbotStream 내부로 이동 (추천)**

```python
class ChatbotStream:
    def __init__(self, model, system_role, instruction, **kwargs):
        # ... 기존 초기화 ...
        
        # FunctionCalling 내부 초기화
        from .functioncalling import FunctionCalling, tools
        self.func_calling = FunctionCalling(
            model=model,
            available_functions={
                # 필요한 함수들 등록
            }
        )
        self.tools = tools
```

**옵션 B: 의존성 주입 (더 유연)**

```python
# routes.py
from app.chatbotDirectory.functioncalling import FunctionCalling, tools

func_calling = FunctionCalling(model=model.basic, available_functions={...})

chatbot = ChatbotStream(
    model=model.advanced,
    system_role="...",
    instruction="...",
    func_calling=func_calling,  # 주입
    tools=tools,
)
```

---

## 🔄 마이그레이션 단계

### Phase 0: 파일 구조 재구성 (신규)
- [ ] `ai/` 디렉토리 생성
- [ ] `chatbotDirectory/` → `ai/chatbot/` 이동 및 파일 분리
  - [ ] `chatbot.py` → `stream.py` 이름 변경
  - [ ] `common.py` → `config.py` 이름 변경
  - [ ] 메타데이터 클래스를 `metadata.py`로 분리
- [ ] `functioncalling.py` → `ai/functions/` 모듈화
  - [ ] `FunctionCalling` → `analyzer.py`
  - [ ] 각 함수별 파일 분리 (`web_search.py`, `cafeteria.py` 등)
  - [ ] `tools` 정의 → `tools.py`
- [ ] `loding/` → `ai/data/` 이동 및 이름 수정
  - [ ] `documentLoding.py` → `document_loader.py`
  - [ ] `mongodbConnect.py` → `mongodb_client.py`
  - [ ] `vector_db_upload.py` → `vector_uploader.py`
- [ ] `rag/` → `ai/rag/` 이동
- [ ] 테스트 파일 통합
  - [ ] `tests/` 디렉토리 생성
  - [ ] `test.py` → `tests/test_chatbot.py`
  - [ ] `test_stream_chat.py` → `tests/test_stream_chat.py`
- [ ] 모든 import 경로 업데이트 (`app.ai.*` 형식으로)

### Phase 1: 준비 단계
- [ ] `RagMetadata`, `FunctionCallMetadata`, `ChatMetadata` 클래스 정의 (`ai/chatbot/metadata.py`)
- [ ] `ai/chatbot/stream.py`에 헬퍼 메서드 스텁 작성

### Phase 2: 헬퍼 메서드 구현 (routes.py → stream.py)

> **목표**: routes.py의 복잡한 로직을 ChatbotStream의 private 메서드로 이동

#### 2.1 준비 작업
- [ ] `ai/chatbot/stream.py` 현재 상태 확인
- [ ] `api/routes.py`에서 이동할 로직 파악
- [ ] 필요한 import 추가

#### 2.2 언어 지침 메서드 (`_get_language_instruction`)
- [ ] routes.py에서 `instruction_map` 로직 복사
- [ ] `_get_language_instruction(language: str) -> str` 메서드 구현
- [ ] 8개 언어 지원 (KOR, ENG, VI, JPN, CHN, UZB, MNG, IDN)
- [ ] 기본값: KOR

**코드 위치**: routes.py 약 150-160줄

#### 2.3 함수 호출 메서드 (`_analyze_and_execute_functions`)
- [ ] routes.py에서 함수 호출 섹션 전체 복사 (약 120줄)
- [ ] `async def _analyze_and_execute_functions(message: str) -> List[FunctionCallMetadata]` 시그니처 유지
- [ ] FunctionCalling.analyze() 결과를 기반으로 안전하게 함수 실행
- [ ] 실패/미등록 함수 대비 예외 처리 및 로깅 추가
- [ ] 학식 키워드 기반 fallback 호출(규칙 기반) 포함
- [ ] 실행 결과를 `FunctionCallMetadata` 목록으로 직렬화하여 반환

**코드 위치**: routes.py 약 260-380줄

**세부 단계**
1. **함수 분석 호출**: `self.func_calling.analyze(message, self.tools)`로 tool 호출 계획을 받아옵니다. 결과 객체가 `function_call` 타입인지 확인 후만 처리합니다.
2. **인자 파싱 & 유효성 검사**: `json.loads(tool_call.arguments)`로 파싱하되 실패 시 건너뛰고 디버그 로그 남깁니다. `dict`가 아닐 경우 무시합니다.
3. **함수 실행**: `self.available_functions`에서 함수 레퍼런스를 찾고, 
   - `search_internet`는 `chat_context=self.context[:]` 인자를 추가 주입
   - `get_halla_cafeteria_menu`는 `date`, `meal` 기본값 보강
   - 실행 도중 예외 발생 시 메타데이터에 에러 메시지를 기록하고 다음 호출로 진행
4. **메타데이터 누적**: 각 호출에 대해 `FunctionCallMetadata` 생성
   - `name`, `arguments`, `output`, `call_id`, `is_fallback=False`
   - 출력이 너무 길 경우 2~3줄로 자르고 원본은 로그에만 남김
5. **학식 보강 Fallback**: LLM이 호출하지 않아도 "학식", "식단", "메뉴" 등의 키워드가 포함되면 fallback 실행
   - 날짜/끼니 추출 (`정규식`, `meal_pref`)
   - 성공 시 `call_id="cafeteria_auto"`, `is_fallback=True`로 메타데이터 추가
   - 실패 시 경고 로그 출력
6. **웹검색 상태 갱신**: 반환 예정 `ChatMetadata`에서 `web_search_status` 변경을 위해 검색 함수 호출 여부를 boolean으로 기록합니다.
7. **반환값**: `List[FunctionCallMetadata]`와 학식 fallback 결과, 웹검색 상태를 함께 리턴하거나 상위 메서드가 참조할 수 있도록 속성에 저장합니다.

**의사 코드**
```python
func_results: List[FunctionCallMetadata] = []
web_search_used = False

for tool_call in self.func_calling.analyze(message, self.tools):
    if getattr(tool_call, "type", None) != "function_call":
        continue

    func_name = tool_call.name
    func_args = self._safe_parse_arguments(tool_call.arguments)
    if func_args is None:
        continue

    func = self.available_functions.get(func_name)
    if not func:
        self._dbg(f"[FUNCTION] 미등록 함수: {func_name}")
        continue

    try:
        if func_name == "search_internet":
            func_args.setdefault("chat_context", self.context[:])
        elif func_name == "get_halla_cafeteria_menu":
            func_args.setdefault("date", "오늘")

        output = func(**func_args)
        if func_name == "search_internet":
            web_search_used = True

        func_results.append(FunctionCallMetadata(
            name=func_name,
            arguments=func_args,
            output=str(output),
            call_id=getattr(tool_call, "call_id", "call_unknown"),
        ))
    except Exception as exc:
        self._dbg(f"[FUNCTION] {func_name} 실행 실패: {exc}")

# 규칙 기반 학식 fallback
if self._needs_cafeteria_fallback(message, func_results):
    fallback_meta = self._run_cafeteria_fallback(message)
    if fallback_meta:
        func_results.append(fallback_meta)

return func_results, web_search_used
```

**검증 포인트**
- 함수 호출 실패가 스트림 전체를 중단시키지 않아야 함 (try/except).
- `FunctionCallMetadata`의 `arguments`는 JSON 직렬화 가능한 dict로 유지.
- fallback 호출 시 `is_fallback=True`, `call_id="cafeteria_auto"` 등 메타데이터 규칙 준수.
- `search_internet`를 수행한 경우 상위에서 `metadata.web_search_status="ok"`로 표시할 수 있도록 상태값 반환.

#### 2.4 RAG 컨텍스트 요약 메서드 (`_condense_rag_context`)
- [ ] routes.py에서 `condense_prompt` 로직 복사
- [ ] `async def _condense_rag_context(user_question: str, raw_context: str) -> str` 구현
- [ ] OpenAI API 호출 (model.basic 사용)
- [ ] 에러 처리 (요약 실패 시 원본 반환)

**코드 위치**: routes.py 약 190-250줄 (60줄)

**핵심 로직**:
```python
# 요약 프롬프트 구성
condense_prompt = [
    {"role": "system", "content": "당신은 규정 문서 요약 전문가입니다..."},
    {"role": "user", "content": f"질문: {user_question}\n\n문서:\n{raw_context}"}
]

# OpenAI 호출
response = client.responses.create(
    model=model.basic,
    messages=condense_prompt,
    max_completion_tokens=1500
)
return response.output.choices[0].message.content
```

#### 2.5 최종 컨텍스트 구성 메서드 (`_build_final_context`)
- [ ] routes.py에서 `sections` 구성 로직 복사 (약 160줄)
- [ ] `def _build_final_context(message, condensed_rag, func_results) -> List[Dict[str, str]]` 구현
- [ ] 7가지 섹션 조립:
  1. 사용자쿼리지침
  2. 일반지침
  3. 기억검색지침 + 내용
  4. 웹검색지침 + 결과
  5. 함수결과지침 + 내용
  6. 통합지침
  7. 최종 시스템 메시지
- [ ] temp_context 반환

**코드 위치**: routes.py 약 390-550줄

**핵심 구조**:
```python
sections = []
temp_context = list(self.context)  # 기존 대화 복사

# 1. 사용자쿼리지침
sections.append("[사용자쿼리지침]\n...")

# 2. 일반지침
sections.append("[일반지침]\n...")

# 3. 기억검색지침 (RAG)
if condensed_rag:
    sections.append(f"[기억검색지침]\n{condensed_rag}")

# 4. 웹검색지침
web_search_func = next((f for f in func_results if f.name == "search_internet"), None)
if web_search_func:
    sections.append(f"[웹검색지침]\n{web_search_func.output}")

# 5. 함수결과지침 (학식, 공지사항 등)
# ...

# 6. 통합지침
sections.append("[통합지침]\n...")

# 최종 시스템 메시지 추가
temp_context.append({
    "role": "system",
    "content": "\n\n".join(sections)
})

return temp_context
```

#### 2.6 OpenAI 스트리밍 메서드 (`_stream_openai_response`)
- [ ] routes.py에서 `generate_with_tool()` 로직 복사 (약 60줄)
- [ ] `async def _stream_openai_response(context) -> AsyncGenerator[Dict, None]` 구현
- [ ] OpenAI Responses API 스트리밍 호출
- [ ] delta 이벤트 처리
- [ ] completed 이벤트 처리
- [ ] 에러 처리

**코드 위치**: routes.py 약 560-620줄

**핵심 로직**:
```python
stream = client.responses.create(
    model=self.model,
    messages=context,
    stream=True
)

completed_text = ""
for event in stream:
    if event.type == "response.delta":
        yield {
            "type": "delta",
            "content": event.delta
        }
        completed_text += event.delta
    elif event.type == "response.completed":
        yield {
            "type": "completed",
            "text": completed_text
        }
```

#### 2.7 검증
- [ ] 각 헬퍼 메서드에 타입 힌트 추가
- [ ] Docstring 작성 (한국어)
- [ ] routes.py와 동일한 동작 확인
- [ ] import 에러 없는지 확인

### Phase 3: 통합 메서드 작성
- [ ] `stream_chat()` 메서드 구현 (모든 헬퍼 조합)
- [ ] JSON Lines 응답 포맷 구현
- [ ] 메타데이터 전송 로직 추가

### Phase 4: routes.py 리팩터링
- [ ] 기존 `/chat` 엔드포인트를 `chatbot.stream_chat()` 호출로 단순화
- [ ] 불필요한 import 제거
- [ ] FunctionCalling 초기화 위치 결정 (ChatbotStream 내부 vs 의존성 주입)

### Phase 5: 테스트 및 검증
- [ ] 일반 질문 테스트
- [ ] RAG 질문 테스트 (졸업 규정)
- [ ] 함수 호출 테스트 (학식 메뉴)
- [ ] 복합 질문 테스트 (RAG + 웹검색)
- [ ] 메타데이터 응답 확인
- [ ] 스트리밍 동작 확인

### Phase 6: 문서화
- [ ] `stream_chat()` API 문서 작성
- [ ] 메타데이터 구조 문서화
- [ ] 프론트엔드 통합 가이드 작성
- [ ] 새 파일 구조 README 업데이트

---

## 📊 예상 효과

### Before (현재)
- routes.py: **440줄** (복잡한 챗봇 로직 포함)
- chatbot.py: **422줄** (기본 스트리밍만)
- **결합도**: 높음 (라우터가 챗봇 내부 로직 알아야 함)
- **재사용성**: 낮음 (코드 중복 필요)
- **테스트**: 어려움 (라우터 레벨에서만 가능)

### After (목표)
- routes.py: **~30줄** (단순 요청/응답 처리)
- chatbot.py: **~800줄** (모든 챗봇 로직 포함)
- **결합도**: 낮음 (라우터는 챗봇 인터페이스만 알면 됨)
- **재사용성**: 높음 (다른 엔드포인트에서도 사용 가능)
- **테스트**: 쉬움 (ChatbotStream 단위 테스트 가능)

---

## 🚨 주의사항

### 1. 비동기 처리
- `stream_chat()`은 `async def`로 정의
- OpenAI API 호출 시 `await` 사용
- `AsyncGenerator` 반환 타입 명시

### 2. 에러 처리
- RAG 실패 시 fallback 로직
- 함수 호출 실패 시 graceful degradation
- 스트리밍 중 에러 발생 시 클라이언트에 알림

### 3. 성능 고려
- 긴 문서 요약 시 토큰 제한 주의
- 메타데이터 크기 제한 (너무 크면 압축/축약)
- 동시 요청 처리 (FastAPI의 비동기 장점 활용)

### 4. 하위 호환성
- 기존 API 응답 포맷 유지 (또는 버전 분리)
- 메타데이터는 선택적으로 반환 (클라이언트가 요청한 경우만)

---

## 📝 다음 단계

1. **데이터 클래스 정의** (`RagMetadata`, `FunctionCallMetadata`, `ChatMetadata`)
2. **헬퍼 메서드 구현** (언어 지침, RAG 요약, 함수 호출, 컨텍스트 구성, 스트리밍)
3. **`stream_chat()` 메서드 통합**
4. **routes.py 단순화**
5. **테스트 및 검증**

---

## 참고 자료

- [RAG 분리 계획 (Phase 2)](./RAG_분리_계획.md)
- [프론트엔드 스트리밍 가이드 (필독!)](./프론트엔드_스트리밍_가이드.md) ⭐
- [OpenAI Responses API Streaming](https://platform.openai.com/docs/api-reference/streaming)
- [FastAPI StreamingResponse](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse)
- [JSON Lines Format](https://jsonlines.org/)
