# 챗봇 스트리밍 API - 프론트엔드 통합 가이드

> **대상**: 프론트엔드 개발자  
> **작성일**: 2025-10-09  
> **관련 Phase**: Phase 2-4 (stream_chat() 구현)

---

## 📋 목차

1. [배경: 왜 JSON Lines 포맷으로 변경하나요?](#1-배경-왜-json-lines-포맷으로-변경하나요)
2. [이전 상황 (변경 전)](#2-이전-상황-변경-전)
3. [새로운 스트리밍 방식 (변경 후)](#3-새로운-스트리밍-방식-변경-후)
4. [프론트엔드에서 해야 할 일](#4-프론트엔드에서-해야-할-일)
5. [예제 코드](#5-예제-코드)
6. [FAQ](#6-faq)

---

## 1. 배경: 왜 JSON Lines 포맷으로 변경하나요?

### 🤔 문제 상황

**질문**: "스트림으로 오는 청크 데이터와 RAG 판단 근거/문서를 어떻게 동시에 받을 수 있어?"

**기존 방식의 한계**:
```
현재 → OpenAI API → 서버 → 프론트
        순수 텍스트   순수 텍스트만 전송
                      "안녕하세요 졸업 규정은..."
```

- OpenAI는 **텍스트 청크만** 보내줌 (메타데이터 없음)
- 우리가 만든 **RAG 결과**(어떤 문서 사용했는지, 규정 질문인지 등)를 함께 보낼 방법이 없음
- **함수 호출 결과**(웹검색, 학식 메뉴)도 전달 불가능

### 💡 해결 방법: JSON Lines (NDJSON) 포맷

**새로운 방식**:
```
OpenAI → 서버 (텍스트만 받음)
         ↓
       JSON으로 포장 + 메타데이터 추가
         ↓
       프론트 (타입별로 처리)
```

**핵심 아이디어**:
1. OpenAI에서 온 **텍스트 청크**를 JSON 객체로 감싸서 보냄
2. 텍스트가 끝나면 **메타데이터**(RAG 결과, 함수 호출 내역)를 추가로 전송
3. 한 줄에 하나의 JSON 객체 (JSON Lines 포맷)

---

## 2. 이전 상황 (변경 전)

### 기존 API 응답 (단순 텍스트 스트리밍)

```http
POST /chat
Content-Type: application/json

{
  "message": "졸업 규정을 알려주세요",
  "language": "KOR"
}
```

**응답** (Content-Type: `text/plain`):
```
안녕하세요 졸업 규정은...
```

### 문제점

1. **텍스트만** 받을 수 있음
2. RAG가 사용되었는지 알 수 없음
3. 어떤 문서를 참조했는지 알 수 없음
4. 웹검색/학식 조회 결과가 사용되었는지 불명확
5. 디버깅/로깅 어려움

---

## 3. 새로운 스트리밍 방식 (변경 후)

### Phase 2-4에서 구현될 새 API

```http
POST /chat
Content-Type: application/json

{
  "message": "졸업 규정을 알려주세요",
  "language": "KOR"
}
```

**응답** (Content-Type: `application/x-ndjson`):
```json
{"type":"delta","content":"안녕하세요"}
{"type":"delta","content":" 졸업"}
{"type":"delta","content":" 규정은"}
{"type":"delta","content":" ..."}
{"type":"metadata","data":{"rag":{"is_regulation":true,"gate_reason":"LLM 판단: 졸업 규정 관련 질문","context_source":"mongo","hits_count":5,"document_count":3,"preview_count":0,"chunk_ids":["673abc123..."],"has_condensed_context":true},"functions":[{"name":"search_internet","arguments":{"query":"한라대 졸업 요건"},"output":"검색 결과...","call_id":"call_123","is_fallback":false}],"web_search_status":"ok"}}
{"type":"done"}
```

### 메시지 타입 3가지

#### 1️⃣ `delta` - 텍스트 청크 (실시간)
```json
{
  "type": "delta",
  "content": "안녕하세요"
}
```
- OpenAI가 보낸 텍스트를 실시간으로 전달
- 화면에 바로 표시

#### 2️⃣ `metadata` - 메타데이터 (텍스트 완료 후)
```json
{
  "type": "metadata",
  "data": {
    "rag": {
      "is_regulation": true,
      "gate_reason": "LLM 판단: 졸업 규정 관련 질문",
      "context_source": "mongo",
      "hits_count": 5,
      "document_count": 3,
      "preview_count": 0,
      "chunk_ids": ["673abc123...", "673def456..."],
      "has_condensed_context": true
    },
    "functions": [
      {
        "name": "search_internet",
        "arguments": {"query": "한라대 졸업 요건"},
        "output": "검색 결과: ...",
        "call_id": "call_123",
        "is_fallback": false
      }
    ],
    "web_search_status": "ok"
  }
}
```

**메타데이터 필드 설명**:

| 필드 | 설명 |
|------|------|
| `rag.is_regulation` | 규정 질문 여부 (true/false) |
| `rag.gate_reason` | 규정 판단 근거 (LLM 추론 또는 키워드 매칭) |
| `rag.context_source` | 컨텍스트 출처: `"mongo"` (DB 본문) / `"preview"` (Pinecone 미리보기) / `"none"` (자료 없음) |
| `rag.hits_count` | Pinecone 검색 히트 수 |
| `rag.document_count` | MongoDB에서 가져온 문서 수 |
| `rag.preview_count` | Pinecone 미리보기 사용 수 (fallback) |
| `rag.chunk_ids` | MongoDB 청크 ID 목록 (디버깅용) |
| `rag.has_condensed_context` | 요약된 컨텍스트 사용 여부 |
| `functions[]` | 호출된 함수 목록 (웹검색, 학식, 공지사항 등) |
| `functions[].is_fallback` | 보강 호출 여부 (LLM이 아닌 규칙 기반) |
| `web_search_status` | 웹검색 상태: `"ok"` / `"empty-or-error"` / `"not-run"` |

#### 3️⃣ `done` - 완료 신호
```json
{
  "type": "done"
}
```
- 스트리밍 종료
- 연결 닫기

---

## 4. 프론트엔드에서 해야 할 일

### 📌 단계별 구현 가이드

#### Step 1: Fetch API로 스트리밍 요청

```javascript
const response = await fetch('/chat', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    message: '졸업 규정을 알려주세요',
    language: 'KOR'
  })
});
```

#### Step 2: ReadableStream 읽기

```javascript
const reader = response.body
  .pipeThrough(new TextDecoderStream())
  .getReader();
```

#### Step 3: 한 줄씩 파싱 (JSON Lines)

```javascript
let buffer = '';
let fullText = '';  // 전체 텍스트 누적
let metadata = null;  // 메타데이터 저장

while (true) {
  const { value, done } = await reader.read();
  
  if (done) break;
  
  buffer += value;
  const lines = buffer.split('\n');
  buffer = lines.pop() || '';  // 마지막 불완전한 줄은 보관
  
  for (const line of lines) {
    if (!line.trim()) continue;  // 빈 줄 무시
    
    const message = JSON.parse(line);
    
    if (message.type === 'delta') {
      // 텍스트 청크 → 화면에 바로 표시
      fullText += message.content;
      updateChatUI(fullText);  // 실시간 업데이트
      
    } else if (message.type === 'metadata') {
      // 메타데이터 → 저장 (나중에 표시)
      metadata = message.data;
      
    } else if (message.type === 'done') {
      // 완료 → 메타데이터 표시
      if (metadata) {
        displayMetadata(metadata);
      }
      break;
    }
  }
}
```

#### Step 4: UI 업데이트 함수 예시

```javascript
// 실시간 텍스트 업데이트
function updateChatUI(text) {
  const chatBubble = document.getElementById('chat-response');
  chatBubble.textContent = text;
}

// 메타데이터 표시
function displayMetadata(metadata) {
  if (metadata.rag && metadata.rag.is_regulation) {
    // 규정 질문 배지 표시
    showBadge('📚 규정 문서 참조');
    
    // 참조 문서 표시
    if (metadata.rag.document_count > 0) {
      showSourceInfo(`${metadata.rag.document_count}개 문서 참조`);
    }
  }
  
  // 웹검색 사용 표시
  if (metadata.web_search_status === 'ok') {
    showBadge('🔍 웹검색 결과 포함');
  }
  
  // 학식 메뉴 조회 표시
  const cafeteriaFunc = metadata.functions.find(
    f => f.name === 'get_halla_cafeteria_menu'
  );
  if (cafeteriaFunc) {
    showBadge('🍽️ 학식 메뉴 조회');
  }
}
```

---

## 5. 예제 코드

### 완전한 React 예제

```jsx
import { useState } from 'react';

function ChatBot() {
  const [message, setMessage] = useState('');
  const [response, setResponse] = useState('');
  const [metadata, setMetadata] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setResponse('');
    setMetadata(null);

    try {
      const res = await fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message,
          language: 'KOR'
        })
      });

      const reader = res.body
        .pipeThrough(new TextDecoderStream())
        .getReader();

      let buffer = '';
      let fullText = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += value;
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;
          
          const msg = JSON.parse(line);

          if (msg.type === 'delta') {
            fullText += msg.content;
            setResponse(fullText);  // 실시간 업데이트
            
          } else if (msg.type === 'metadata') {
            setMetadata(msg.data);
            
          } else if (msg.type === 'done') {
            setIsLoading(false);
          }
        }
      }
    } catch (error) {
      console.error('스트리밍 에러:', error);
      setIsLoading(false);
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="질문을 입력하세요"
        />
        <button type="submit" disabled={isLoading}>
          전송
        </button>
      </form>

      {/* 답변 표시 */}
      <div className="response">
        {response}
      </div>

      {/* 메타데이터 표시 */}
      {metadata && (
        <div className="metadata">
          {metadata.rag?.is_regulation && (
            <span className="badge">📚 규정 문서 참조</span>
          )}
          {metadata.web_search_status === 'ok' && (
            <span className="badge">🔍 웹검색 결과 포함</span>
          )}
          {metadata.functions?.some(f => f.name === 'get_halla_cafeteria_menu') && (
            <span className="badge">🍽️ 학식 메뉴 조회</span>
          )}
        </div>
      )}
    </div>
  );
}

export default ChatBot;
```

### 완전한 Vanilla JS 예제

```html
<!DOCTYPE html>
<html>
<head>
  <title>챗봇 테스트</title>
  <style>
    .badge {
      background: #e3f2fd;
      padding: 4px 8px;
      border-radius: 4px;
      margin: 4px;
      display: inline-block;
    }
    .response {
      background: #f5f5f5;
      padding: 16px;
      margin: 16px 0;
      border-radius: 8px;
      min-height: 100px;
    }
  </style>
</head>
<body>
  <h1>챗봇 스트리밍 테스트</h1>
  
  <form id="chat-form">
    <input type="text" id="message" placeholder="질문을 입력하세요" />
    <button type="submit">전송</button>
  </form>

  <div id="response" class="response"></div>
  <div id="metadata"></div>

  <script>
    document.getElementById('chat-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const message = document.getElementById('message').value;
      const responseDiv = document.getElementById('response');
      const metadataDiv = document.getElementById('metadata');
      
      responseDiv.textContent = '';
      metadataDiv.innerHTML = '';

      const res = await fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, language: 'KOR' })
      });

      const reader = res.body.pipeThrough(new TextDecoderStream()).getReader();
      
      let buffer = '';
      let fullText = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += value;
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;
          
          const msg = JSON.parse(line);

          if (msg.type === 'delta') {
            fullText += msg.content;
            responseDiv.textContent = fullText;
            
          } else if (msg.type === 'metadata') {
            const data = msg.data;
            
            if (data.rag?.is_regulation) {
              metadataDiv.innerHTML += '<span class="badge">📚 규정 문서 참조</span>';
            }
            if (data.web_search_status === 'ok') {
              metadataDiv.innerHTML += '<span class="badge">🔍 웹검색 결과 포함</span>';
            }
            if (data.functions?.some(f => f.name === 'get_halla_cafeteria_menu')) {
              metadataDiv.innerHTML += '<span class="badge">🍽️ 학식 메뉴 조회</span>';
            }
          }
        }
      }
    });
  </script>
</body>
</html>
```

---

## 6. FAQ

### Q1. 왜 한 줄에 하나의 JSON 객체인가요?

**A**: JSON Lines (NDJSON) 포맷이기 때문입니다.
- 스트리밍 환경에서 파싱하기 쉬움
- 각 줄이 독립적인 JSON → 부분적으로 읽어도 파싱 가능
- 표준 포맷 (많은 API가 사용)

### Q2. `delta` 메시지가 끝났는지 어떻게 알 수 있나요?

**A**: `metadata` 또는 `done` 메시지를 받으면 텍스트 스트리밍이 끝난 것입니다.

**메시지 순서**:
```
delta → delta → delta → ... → metadata → done
```

### Q3. 메타데이터가 없는 경우도 있나요?

**A**: 네, 있습니다.
- RAG가 사용되지 않은 일반 질문 → `rag` 필드 `null`
- 함수 호출 없음 → `functions` 빈 배열 `[]`
- 웹검색 안 함 → `web_search_status: "not-run"`

**예시**:
```json
{
  "type": "metadata",
  "data": {
    "rag": null,
    "functions": [],
    "web_search_status": "not-run"
  }
}
```

### Q4. 에러 처리는 어떻게 하나요?

**A**: HTTP 상태 코드와 JSON 파싱 에러를 확인하세요.

```javascript
try {
  const res = await fetch('/chat', {...});
  
  if (!res.ok) {
    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
  }
  
  // 스트리밍 처리...
  
} catch (error) {
  if (error instanceof SyntaxError) {
    console.error('JSON 파싱 에러:', error);
  } else {
    console.error('네트워크 에러:', error);
  }
}
```

### Q5. 텍스트가 UTF-8로 깨지는데요?

**A**: `TextDecoderStream`을 사용하세요.

```javascript
// ✅ 올바른 방법
const reader = response.body
  .pipeThrough(new TextDecoderStream())  // UTF-8 디코딩
  .getReader();

// ❌ 잘못된 방법
const reader = response.body.getReader();  // Uint8Array 반환 (깨짐)
```

### Q6. 디버깅 시 로그를 보고 싶어요

**A**: 각 메시지를 콘솔에 출력하세요.

```javascript
for (const line of lines) {
  if (!line.trim()) continue;
  
  const msg = JSON.parse(line);
  console.log('[STREAM]', msg.type, msg);  // 디버깅 로그
  
  // 처리 로직...
}
```

---

## 📚 관련 문서

- [챗봇 로직 분리 계획 (Phase 3)](./챗봇_로직_분리_계획.md)
- [RAG 분리 계획 (Phase 2)](./RAG_분리_계획.md)
- [JSON Lines 포맷 명세](https://jsonlines.org/)
- [Fetch API - Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams)

---

## 🔄 변경 이력

| 날짜 | 변경 내용 |
|------|-----------|
| 2025-10-09 | 초기 문서 작성 (Phase 2-4 대비) |
